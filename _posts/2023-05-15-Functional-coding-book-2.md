---
title: 2장 현실에서의 함수형 사고
author: park
date: 2023-05-15 13:40:00 +0800
categories: [CS, 쏙쏙 들어오는 함수형 코딩(2023-05 ~]
tags: [typography]
math: true
mermaid: true
# image: 
#   path: /commons/devices-mockup.png
#   lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
#   alt: Responsive rendering of Chirpy theme on multiple devices.
---

<!-- 표지 -->
<!-- 로컬 -->
<!-- ![image](https://github.com/4862abd/4862abd.github.io/assets/77370682/ce261bb4-c073-43f4-a3df-9b4411144ad4) -->
<!-- 배포 -->
![image](https://github.com/cotes2020/jekyll-theme-chirpy/assets/77370682/25f9604c-29c7-4858-af75-82d6da2653c7)

---

## 2장 현실에서의 함수형 사고.

### 소제목 목록
● 토니 피자에 오신 것을 환영합니다<br/>
● 파트 1: 액션과 계산, 데이터<br/>
● 계층화 설계 맛보기<br/>
● 파트 2: 일급 추상<br/>
● 분산 시스템을 타임라인으로 시각화하기<br/>
● 타임라인 커팅: 로봇이 서로를 기다릴 수 있게 하기<br/>
● 좋은 경험을 통해 타임라인에 대해 배운 것<br/>
<br/>

### ● 토니 피자에 오신 것을 환영합니다

책에서 함수형 프로그래밍의 기초가 되는 함수형 사고를 위해 예시를 들었다.<br/>
예시에 제목을 든다면 "어서오세요, 토니의 피자 샵" 정도가 되겠다.<br/>
주방과 재고 창고가 어떻게 관리되는지 확인하면서 함수형 사고를 접목 시켜보자고 한다.<br/>

#### 파트 1, 액션과 계산
요리 재료 등 자원(리소스, Resource)를 사용하는 코드를 액션으로 구분하고 나머지 코드는 계산으로 구분했다.<br/>
이에따라 발생할 <b>액션, 계산, 데이터를 구분하고 계층형 설계(Stratified design)의 원칙을 접목</b>시켜 알아보자.<br/>
<br/>
<br/>

#### 파트 2, 일급 추상
토니는 가게에서 로봇들과 같이 업무를 진행한다고 한다.<br/>
분명한 의미의 분산 시스템이고 가끔 실패하는 분산 시스템을 이해하려고 <b>타임라인 다이어그램(Timeline diagram)</b> 을 사용했다.<br/>
또 여러 로봇이 협력할 수 있도록 <b>함수를 인자로 받는 <span style="color: red;">일급 함수(First-class function)</span></b> 를 사용했다.<br/>
<br/>
이제 얼마나 더 빨리 많이 피자를 만들 수 있었는지 확인해보자.<br/>
<br/>

---
<br/>

### ● 파트 1: 액션과 계산, 데이터

매장이 빠르게 성장해 감에 따라 확장성 문제를 해결하기 위해 함수형 사고를 적용해서 어려움을 이겨내려 한다.<br/>
이를 위해 가장 먼저 설명했던 개념인 액션, 계산, 데이터로 구분하는 함수형 사고를 이용하려 한다.<br/>
<br/>
<h4>1. 액션</h4>
호출 횟수와 시점에 의존하는 것으로, 오븐이나 배달차량 같은 자원과 요리 재료를 사용하는 것은 액션이다.<br/>
<br/>
예시:

1. 판죽 펴기
2. 피자 배달
3. 재료 주문

<h4>2. 계산</h4>
어떤 것을 경정하거나 계획하는 것을 의미하고, 실행해도 다른 곳에 부수 효과가 발생하지 않는다.<br/>
<br/>
예시:

1. 조리법에 나온 것을 두 배로 만들기
2. 쇼핑 목록 결정


<h4>3. 데이터</h4>
변경 불가능한 데이터를 최대한 이용하려 한다.<br/>
결제, 재고, 피자 조리법 같은 것이 데이터로 유연하기 때문에 여러 방법으로 저장 가능하고 전송 가능하다.<br/>
<br/>
예시:

1. 고객 주문
2. 영수증
3. 조리법
<br/>

---
<br/>

### ● 계층화 설계 맛보기

<!-- 계층형 설계 -->
<!-- 로컬 -->
<!-- ![image](https://github.com/4862abd/4862abd.github.io/assets/77370682/9eb488dd-b612-42d4-93f9-9e0b8a4f4f0e) -->
<!-- 배포 -->
![image](https://github.com/cotes2020/jekyll-theme-chirpy/assets/77370682/de72a2b6-ede8-4b0f-893b-5e755d0c195b)

<br/>
위 사진의 각 계층은 그 아래의 계층을 기반으로 만들어 진다.<br/>
그래서 더욱 안정적인 기반 위에 작성할 수 있으며, 이런 구조로 소프트웨어를 만들면 코드를 쉽게 변경할 수 있다.<br/>
또한, 가장 위에 있는 코드는 의존성이 거의 없기 때문에 쉽게 바꿀 수 있다는 장점이 생긴다.<br/>
<br/>
이러한 패턴을 <b>계층형 설계(Stratified design)<span style="color: red;">＊</span></b> 이라고 한다.<br/>
일반적으로 <b>비즈니스 규칙, 도메인 규칙, 기술 스택 계층</b>으로 나눠진다.<br/>

> 일반적으로 알려진 계층형 설계(계층형 아키텍처) 와 그것을 달리하는 것 같다.<br/>
> 일반적인 <b>3-계층(Tier)</b>의 그것은 이렇게 설명된다.<br/>
> <br/>
> ● Presentation Tier<br/>
> ㄴ 일반 사용자가 애플리케이션과 상호작용하는 애플리케이션의 UI 및 커뮤니케이션 계층<br/>
> ㄴ 주요 목적: 정보 표시 및 정보 수집<br/>
> <br/>
> ● Application Tier<br/>
> ㄴ 논리 계층 또는 중간 계층, 애플리케이션의 핵심<br/>
> ㄴ 특정 비즈니스 규칙 세트인 비즈니스 논리를 사용하여 프레젠테이션 계층에서 수집된 정보가 처리되고, API 호출을 통해 데이터 계층과 통신한다.<br/>
> ㄴ 주요 목적: 정보 처리 및 데이터 계층의 데이터를 추가, 삭제 또는 수정<br/>
> ㄴ 일반적으로 사용되는 언어: Python, Java, Perl, PHP, Ruby<br/>
> <br/>
> ● Data Tier<br/>
> ㄴ 데이터베이스 계층, 데이터 액세스 계층, 백엔드라고 불림.<br/>
> ㄴ 애플리케이션 계층이 처리하는 정보가 저장 및 관리되는 곳이며 RDBMS, NoSQL DB 서버(Cassandra, CouchDB, MongoDB 등)일 수 있다.<br/>
> <br/>
> <i> 출처: https://www.ibm.com/kr-ko/topics/three-tier-architecture</i><br/>
> <br/>
> <b>※ 특히 3-계층 아키텍처에 관해서 많이 착각하는 개념이 있는데,</b>(나도 이렇게 공부하기 전에는 착각하고 있었더라.)<br/>
> <b>계층(Tier)</b>과 <b>레이어(Layer)</b>를 <b style="color: red;">혼동</b>하여 사용한다는 것.<br/>
> 우리나라 말로는 Layer가 계층으로 해석될 수 있으니 공부할 때 주의를 요한다.<br/>
> 3-Layer 아키텍처에 관한 설명은 이렇다.<br/>
> <br/>
> ● Presentation Layer<br/>
> ㄴ 모든 컨트롤러와 뷰(UI)가 위치하는 곳으 작업의 총괄을 담당하는 층을 의미한다.<br/>
> ㄴ 데이터가 표시되는 방식과 각 CRUD 작업 흐름의 시작과 관련된 논리만 포함되고, 단순해야 한다.<br/>
> <br/>
> ● Business Logic Layer<br/>
> ㄴ 응용 프로그램의 대부분의 논리가 이 계층에 배치된다.<br/>
> ㄴ 데이터 모델에 대한 자세한 정보나 지식이 없어야 하고, 데이터베이스에 관한 쿼리를 실행할 수 없다.<br/>
> ㄴ input되는 데이터는 Presentation Layer가 기반이 될 것이며, output되는 데이터는 Data Access Layer가 기반이 될 것이다.<br/>
> ㄴ 이 계층에서는 중복된 코드를 줄일 수 있는 많은 기술을 채택, 사용할 수 있으며, 중복을 줄이기 위해 모달, 컴포넌트 형식으로 작은 조각으로 나뉘어 진다.<br/>
> ● Data Access Layer(이후 DAL)<br/>
> ㄴ 데이터 소스와 통신을 구현하는 계층이다.<br/>
> ㄴ 이 계층은 DAL 추상화와 DAL 로 구분된다.<br/>
> ㄴ DAL 추상화 계층은 비즈니스 논리가 데이터 계층과 상호 작용 하는데 필요한 모든 논리가 단일 클래스 집합(계층) 으로 격리되는 "관심사 분리" 개념을 따른다.<br/>
> ㄴ 이를 통해 백엔드 물리적 데이터 스토리지 기술을 더 쉽게 변경할 수 있다.(XML 파일에서 DB로 또는 SQL Server에서 Oracle, MySQL로 이동 등)<br/>
> <br/>
> <i> 출처: https://medium.com/@deanrubin/the-three-layered-architecture-fe30cb0e4a6</i>
{: .prompt-info }
<br/>

---
<br/>

### ● 파트 2: 일급 추상

<!-- 피자 만들기 타임라인 다이어그램 -->
<!-- 로컬 -->
<!-- ![image](https://github.com/4862abd/4862abd.github.io/assets/77370682/edbb0f90-2c31-45ca-b74d-dbd09ef7bd51) -->
<!-- 배포 -->
![image](https://github.com/cotes2020/jekyll-theme-chirpy/assets/77370682/32e63e88-5a48-40fd-b024-9333e6605b3c)
<br/>

<br/>
위의 이미지는 한 대의 로봇이 주문을 받아 피자를 만들고 서빙하는 타임라인 다이어그램이다.<br/>
<i>(번역이 되지 않은 사진을 구하지 못 했다.)</i><br/>
타임라인 다이어그램을 이용해서 실행 지점에 의존하는 개념의 액션이 시간 순서에 따라 어떻게 진행되는지 확인할 수 있다.<br/>
<br/>

---
<br/>

### ● 분산 시스템을 타임라인으로 시각화하기

한 대의 로봇이 처리할 일을 세 대로 확장시켜 업무의 효율성을 높이려 한다.<br/>
배정받을 업무는 이렇게 된다.<br/>
<br/>
![image](https://github.com/cotes2020/jekyll-theme-chirpy/assets/77370682/964316ae-5acf-4639-a792-1871d4795940)
<br/>
각 세대의 타임라인이 섞여 있어서 <b>누가 먼저 시작하고 끝나는지 확인할 수 없다.</b><br/>
이러한 타임라인대로 흘러간다면 피자가 만들어 질지, 어떤 피자가 만들어질지 확인할 수 없다.<br/>

우선 업무를 분담한 대로<br/>

1. 반죽 만들기
2. 치즈 갈기
3. 소스 만들기 등 잡다
<br/>

로 나눠보자.<br/>
<br/>
반죽을 만들거나 치즈를 가는 것은 업무의 순서에서 중요한 포인트이다.<br/>
반죽을 펴고 소스를 뿌려야하는데 반죽은 아직 만들어 지지 않았을 수 있다.<br/>
또, 소스를 뿌렸다면 치즈를 뿌려야 하는데 치즈 갈기가 미리 되지 않으면 뿌릴 치즈가 없다.<br/>
즉, 반죽을 만들고 펴고, 치즈를 갈고 뿌리고, 소스를 만들어 뿌리는 작업 중,<br/>
<b>소스를 만들어 뿌리는 작업이 가장 마지막으로 와야한다.</b><br/>
위의 세가지 업무에서 <b>카테시안 곱<span style="color: red;">＊</span></b>을 이용해 만들어진 조합 중, 이상적인 조합은 두 가지가 나온다.<br/>

> <b>카테시안 곱(Cartesian product)</b><br/>
> 결합할 수 있는 모든 상황을 결합하여 결과를 도출하는 것.<br/>
> ex) n개의 데이터를 모두 사용하여 특정 순서로 나열될 카테시안 곱의 계산식(점화식)은<br/>
> <b>n! (팩토리얼)</b><br/>
> 이 될수 있다.<br/>
{: .prompt-info }

<br/>

1. 반죽 만들기<br/>
2. 치즈 갈기<br/>
3. 소스 만들고 뿌리기<br/>
혹은
1. 치즈 갈기<br/>
2. 반죽 만들기<br/>
3. 소스 만들고 뿌리기<br/>

가 가능한 순서일 것이다.<br/>
이렇게 타임라인을 서로 맞추지 않는 분산 시스템은 예측 불가능한 순서로 실행된다.<br/>
<br/>

---
<br/>
이러한 과정을 통해 피자가게 사장인 토니는 몇가지 포인트를 얻었다고 한다.<br/>

1. <b>기본적으로 타임라인은 서로 순서를 맞추지 않는다.</b><br/>
ㄴ 반죽을 만들지 않아도 소스를 바르려고 하는 등, 타임라인이 제대로 흐르지 않았다.<br/>

2. <b>액션이 실행되는 시간은 중요하지 않다.</b><br/>
ㄴ 소스를 만드는 것이 가장 오래 걸리는 작업이라고 해도 순서에 관계없이 만들어야 한다.<br/>

3. <b>드물지만 타이밍이 어긋나는 경우는 실제로 일어났다.</b><br/>
ㄴ 테스트 시에는 문제 없던 로직이 실제로 동작하거나 너무 많은 요청이 일어나면 오류가 발생했다.<br/>

4. <b>타임라인 다이어그램으로 시스템의 문제를 알 수 있다.</b><br/>
ㄴ 타임라인 다이어그램을 보고 치즈가 제 시간에 준비되지 않은 문제를 파악했다.<br/>
<br/>

이제 해결법을 찾으려 한다.<br/>
<br/>

---
<br/>

### ● 타임라인 커팅: 로봇이 서로를 기다릴 수 있게 하기

<b>타임라인 커팅(Cutting)</b> 이라고 부르는 기술을 접목시키려 한다.<br/>
<b>이는 여러 타임라인이 동시에 진행될 때 서로 순서를 맞추는 방법이라고 하며, 고차 동작(High-order operation)으로 구현</b>한다.<br/>
각 타임라인은 독립적으로 동작하고 작업이 완료되는 다른 타임라인이 끝나기를 기다리기 때문에 어떤 타임라인이 먼저 종료되어도 문제는 없다.<br/>

![image](https://github.com/cotes2020/jekyll-theme-chirpy/assets/77370682/2fadcedf-a797-4ac7-9452-ea58682e090c)

<i>(이미지를 구하지 못 해서, 직접 촬영했다. 화질구지..)</i><br/>
<br/>
이미지의 중간에 점선을 <b>컷(Cut)</b> 이라고 한다.<br/>
마치 종이접기 책에서 접거나 가위로 자르는 부분을 설명할 때 그것과 비슷해 보인다.<br/>
<br/>
이제 순서에 상관없이 특정 작업이 마치면 다음 로직이 진행되기 전까지 대기하는 타임라인 다이어그램을 완성했다.<br/>
<br/>

---
<br/>

### ● 좋은 경험을 통해 타임라인에 대해 배운 것
<br/>

1. <b>타임라인 커팅으로 서로 다른 작업들을 쉽게 이해할 수 있다.</b><br/>
ㄴ 타임라인에 컷을 이용함으로 인해 동시에 준비할 수 있는 재료의 준비에 유연성을 확보 했다.<br/>
ㄴ 또한 피자를 만드는 작업과 재료를 준비하는 작업을 분리함으로 순서대로만 연결되던 타임라인보다 더 빠르게 생산할 수 있게 되었다.<br/>
<br/>

2. <b>타임라인 다이어그램을 사용하면 시간에 따라 진행하는 작업을 쉽게 이해할 수 있다.</b><br/>
ㄴ 토니와 나는 이제 타임라인 다이어그램을 이해할 수 있었지에 동작에 확신이 생겼고, 또한 분산 시스템을 시각화할 수 있는 좋은 방법이 생겼다.<br/>

3. <b>타임라인 다이어그램은 유연하다.</b><br/>
ㄴ 이제 이 타임라인 다이어그램을 통해 쉽게 코딩을 할 수 있고, 동시에 진행되는 작업을 쉽게 모델링 할 수 있다.<br/>

<br/>

---
<br/>

이제 현실에서 함수형 사로를 어떻게 적용하는지 살펴봤다.<br/>
🍕 특히 피자라는 메뉴를 좋아해서 그런지 이해하기 좋았고 이해하고 싶었다. 🍕<br/>
다음 장에서는 액션과 계산, 데이터를 구분하는 함수형 사고의 핵심을 짚는다고 한다.<br/>