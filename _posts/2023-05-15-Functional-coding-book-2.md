---
title: 2장 현실에서의 함수형 사고
author: park
date: 2023-05-15 13:40:00 +0800
categories: [CS, 쏙쏙 들어오는 함수형 코딩(2023-05 ~]
tags: [typography]
math: true
mermaid: true
# image: 
#   path: /commons/devices-mockup.png
#   lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
#   alt: Responsive rendering of Chirpy theme on multiple devices.
---

<!-- 표지 -->
![image](https://github.com/4862abd/4862abd.github.io/assets/77370682/ce261bb4-c073-43f4-a3df-9b4411144ad4)

---

## 2장 현실에서의 함수형 사고.

### 소제목 목록
● 토니 피자에 오신 것을 환영합니다<br/>
● 파트 1: 액션과 계산, 데이터<br/>
● 계층화 설계 맛보기<br/>
● 파트 2: 일급 추상<br/>
● 분산 시스템을 타임라인으로 시각화하기<br/>
● 타임라인 커팅: 로봇이 서로를 기다릴 수 있게 하기<br/>
● 좋은 경험을 통해 타임라인에 대해 배운 것<br/>
<br/>

### ● 토니 피자에 오신 것을 환영합니다

책에서 함수형 프로그래밍의 기초가 되는 함수형 사고를 위해 예시를 들었다.<br/>
예시에 제목을 든다면 "어서오세요, 토니의 피자 샵" 정도가 되겠다.<br/>
주방과 재고 창고가 어떻게 관리되는지 확인하면서 함수형 사고를 접목 시켜보자고 한다.<br/>

#### 파트 1, 액션과 계산
요리 재료 등 자원(리소스, Resource)를 사용하는 코드를 액션으로 구분하고 나머지 코드는 계산으로 구분했다.<br/>
이에따라 발생할 <b>액션, 계산, 데이터를 구분하고 계층형 설계(Stratified design)의 원칙을 접목</b>시켜 알아보자.<br/>
<br/>
<br/>

#### 파트 2, 일급 추상
토니는 가게에서 로봇들과 같이 업무를 진행한다고 한다.<br/>
분명한 의미의 분산 시스템이고 가끔 실패하는 분산 시스템을 이해하려고 <b>타임라인 다이어그램(Timeline diagram)</b> 을 사용했다.<br/>
또 여러 로봇이 협력할 수 있도록 <b>함수를 인자로 받는 <span style="color: red;">일급 함수(First-class function)</span></b> 를 사용했다.<br/>
<br/>
이제 얼마나 더 빨리 많이 피자를 만들 수 있었는지 확인해보자.<br/>
<br/>

---
<br/>

### ● 파트 1: 액션과 계산, 데이터

매장이 빠르게 성장해 감에 따라 확장성 문제를 해결하기 위해 함수형 사고를 적용해서 어려움을 이겨내려 한다.<br/>
이를 위해 가장 먼저 설명했던 개념인 액션, 계산, 데이터로 구분하는 함수형 사고를 이용하려 한다.<br/>
<br/>
<h4>1. 액션</h4>
호출 횟수와 시점에 의존하는 것으로, 오븐이나 배달차량 같은 자원과 요리 재료를 사용하는 것은 액션이다.<br/>
<br/>
예시:

1. 판죽 펴기
2. 피자 배달
3. 재료 주문

<h4>2. 계산</h4>
어떤 것을 경정하거나 계획하는 것을 의미하고, 실행해도 다른 곳에 부수 효과가 발생하지 않는다.<br/>
<br/>
예시:

1. 조리법에 나온 것을 두 배로 만들기
2. 쇼핑 목록 결정


<h4>3. 데이터</h4>
변경 불가능한 데이터를 최대한 이용하려 한다.<br/>
결제, 재고, 피자 조리법 같은 것이 데이터로 유연하기 때문에 여러 방법으로 저장 가능하고 전송 가능하다.<br/>
<br/>
예시:

1. 고객 주문
2. 영수증
3. 조리법
<br/>

---
<br/>

### ● 계층화 설계 맛보기

![image](https://github.com/4862abd/4862abd.github.io/assets/77370682/9eb488dd-b612-42d4-93f9-9e0b8a4f4f0e)

<br/>
위 사진의 각 계층은 그 아래의 계층을 기반으로 만들어 진다.<br/>
그래서 더욱 안정적인 기반 위에 작성할 수 있으며, 이런 구조로 소프트웨어를 만들면 코드를 쉽게 변경할 수 있다.<br/>
또한, 가장 위에 있는 코드는 의존성이 거의 없기 때문에 쉽게 바꿀 수 있다는 장점이 생긴다.<br/>
<br/>
이러한 패턴을 <b>계층형 설계(Stratified design)</b> 이라고 한다.<br/>
일반적으로 <b>비즈니스 규칙, 도메인 규칙, 기술 스택 계층</b>으로 나눠진다.<br/>

> 일반적으로 알려진 계층형 설계(계층형 아키텍처) 와 그것을 달리하는 것 같다.<br/>
> 일반적인 <b>3-계층(Tier)</b>의 그것은 이렇게 설명된다.<br/>
> <br/>
> ● Presentation Tier<br/>
> ㄴ 일반 사용자가 애플리케이션과 상호작용하는 애플리케이션의 UI 및 커뮤니케이션 계층<br/>
> ㄴ 주요 목적: 정보 표시 및 정보 수집<br/>
><br/>
> ● Application Tier<br/>
> ㄴ 논리 계층 또는 중간 계층, 애플리케이션의 핵심<br/>
> ㄴ 특정 비즈니스 규칙 세트인 비즈니스 논리를 사용하여 프레젠테이션 계층에서 수집된 정보가 처리되고, API 호출을 통해 데이터 계층과 통신한다.<br/>
> ㄴ 주요 목적: 정보 처리 및 데이터 계층의 데이터를 추가, 삭제 또는 수정<br/>
> ㄴ 일반적으로 사용되는 언어: Python, Java, Perl, PHP, Ruby<br/>
><br/>
> ● Data Tier<br/>
> ㄴ 데이터베이스 계층, 데이터 액세스 계층, 백엔드라고 불림.<br/>
> ㄴ 애플리케이션 계층이 처리하는 정보가 저장 및 관리되는 곳이며 RDBMS, NoSQL DB 서버(Cassandra, CouchDB, MongoDB 등)일 수 있다.<br/>
><br/>
><i> 출처: https://www.ibm.com/kr-ko/topics/three-tier-architecture</i><br/>
><br/>
> <b>※ 특히 3-계층 아키텍처에 관해서 많이 착각하는 개념이 있는데,</b>(나도 이렇게 공부하기 전에는 착각하고 있었더라.)<br/>
> <b>계층(Tier)</b>과 <b>레이어(Layer)</b>를 <b style="color: red;">혼동</b>하여 사용한다는 것.<br/>
> 우리나라 말로는 Layer가 계층으로 해석될 수 있으니 공부할 때 주의를 요한다.<br/>
> 3-Layer 아키텍처에 관한 설명은 이렇다.<br/>
><br/>
> ● Presentation Layer<br/>
> ㄴ 모든 컨트롤러와 뷰(UI)가 위치하는 곳으 작업의 총괄을 담당하는 층을 의미한다.<br/>
> ㄴ 데이터가 표시되는 방식과 각 CRUD 작업 흐름의 시작과 관련된 논리만 포함되고, 단순해야 한다.<br/>
><br/>
> ● Business Logic Layer<br/>
> ㄴ 응용 프로그램의 대부분의 논리가 이 계층에 배치된다.<br/>
> ㄴ 데이터 모델에 대한 자세한 정보나 지식이 없어야 하고, 데이터베이스에 관한 쿼리를 실행할 수 없다.<br/>
> ㄴ input되는 데이터는 Presentation Layer가 기반이 될 것이며, output되는 데이터는 Data Access Layer가 기반이 될 것이다.<br/>
> ㄴ 이 계층에서는 중복된 코드를 줄일 수 있는 많은 기술을 채택, 사용할 수 있으며, 중복을 줄이기 위해 모달, 컴포넌트 형식으로 작은 조각으로 나뉘어 진다.<br/>
> ● Data Access Layer(이후 DAL)<br/>
> ㄴ 데이터 소스와 통신을 구현하는 계층이다.<br/>
> ㄴ 이 계층은 DAL 추상화와 DAL 로 구분된다.<br/>
> ㄴ DAL 추상화 계층은 비즈니스 논리가 데이터 계층과 상호 작용 하는데 필요한 모든 논리가 단일 클래스 집합(계층) 으로 격리되는 "관심사 분리" 개념을 따른다.<br/>
> ㄴ 이를 통해 백엔드 물리적 데이터 스토리지 기술을 더 쉽게 변경할 수 있다.(XML 파일에서 DB로 또는 SQL Server에서 Oracle, MySQL로 이동 등)<br/>
><br/>
><i> 출처: https://medium.com/@deanrubin/the-three-layered-architecture-fe30cb0e4a6</i>
{: .prompt-info }
<br/>

---
<br/>

### ● 파트 2: 일급 추상

![image](https://github.com/4862abd/4862abd.github.io/assets/77370682/edbb0f90-2c31-45ca-b74d-dbd09ef7bd51)
<br/>

<br/>
위의 이미지는 한 대의 로봇이 주문을 받아 피자를 만들고 서빙하는 타임라인 다이어그램이다.<br/>
<i>(번역이 되지 않은 사진을 구하지 못 했다.)</i><br/>
타임라인 다이어그램을 이용해서 실행 지점에 의존하는 개념의 액션이 시간 순서에 따라 어떻게 진행되는지 확인할 수 있다.<br/>



<br/>

---
<br/>

### ● 실용적인 측면에서 함수형 프로그래밍 정의의 문제점

그래서 이 책에서는 이렇게 설명한다.<br/>
실용적인 측면에서의 함수형 프로그래밍 정의의 문제점 이라고.<br/>
1. <b>부수 효과는 필요하다.</b><br/>
  ㄴ 위의 설명에서 브레이크를 동작하기 위해 밟는 패달이나 선서 설명 등을 통해 공감한다.<br/>
2. <b>함수형 프로그래밍은 부수 효과를 효과적으로 다룰 수 있다.</b><br/>
  ㄴ 함수형 프로그래밍의 정의처럼 순수 함수만을 이용하는 것이 아닌, 순수하지 않은 함수를 효과적으로 다룰 방법이 많다고 한다.<br/>
3. <b>함수형 프로그래밍은 실용적이다.</b><br/>
  ㄴ 수학처럼 정의되어 실용적이지 않게 보이지만 효과적인 프로그램이 많다. <br/>
  ㄴ 이 부분은 나중에 설명이 더 나올 듯 하다.<br/>

<br/>

---
<br/>

### ● 액션과 계산, 데이터 구분하기

즉, 우리는 함수형 프로그래밍을 "정의"하지 말고, 기술적인 측면에서 <b style="color: red;">재해석이 필요</b>하다고 한다.<br/>
이를 효과적으로 다루기 위해 저자는 함수형 프로그래밍을 세 가지 기준으로 분류한다.<br/>
<br/>
<b>액션(Action), 계산(Calculator), 데이터(Data)</b><br/>
<br/>
<br/>
<b>액션(Action)</b>은 부르는 시점에 따라 다른 동작을 하는 즉, <b>부르는 시점에 의존을 하는 동작</b>을 의미한다.<br/>
책에서는 예시로 이메일을 보내는 행위를 든다.<br/>
언제, 몇 번 보냈는지에 따라 받는 이의 메일(데이터)가 변할 수 있다는 것.(예시로 발송 시간 등)<br/>
<br/>
※ 액션의 특징<br/>
1. 시간이 지남에 따라 안전하게 상태를 바꿀 수 있는 방법<br/>
2. 순서를 보장하는 방법<br/>
3. 액션이 정확히 한 번만 실행되게 보장하는 방법<br/>
<br/>

<b>계산(Calculator)</b>은 입력한 값에 대해 일정한 리턴을 하는 것을 의미하고, <b>언제 어떤 요청을 하던 인자가 같다면 항상 같은 리턴을 주는 것</b>을 의미한다.<br/>
외부에 영향을 주지도 않고, 테스트하기 쉬우며 몇 번을 불러도 안전하다.<br/>
책에서는 예시로 sum() 함수를 들었다.<br/>
언제 값을 넣든 1, 2, 3을 넣으면 무조건 6이 리턴된다.<br/>
<br/>
※ 계산의 특징<br/>
1. 정확성을 위한 정적 분석<br/>
2. 소프트웨어에서 쓸 수 있는 수학적 지식<br/>
3. 테스트 전략<br/>
<br/>

<b>데이터(data)</b>는 <b>이벤트에 의한 사실을 기록한 것</b>이라고 한다.<br/>
실행하는 코드처럼 복잡하지 않기에 다른 것과 구분되고, 알아보기 쉬운 속성으로 되어 있으며 그 자체로 가치가 있다.<br/>
같은 데이터를 여러 형태로 해석할 수 있다.<br/>
<br/>
※ 데이터의 특징<br/>
1. 효율적으로 접근하기 위해 데이터를 구성하는 방법<br/>
2. 데이터를 보관하기 위한 기술<br/>
3. 데이터를 이용해 중요한 것을 발견하는 원칙<br/>
<br>

#### 또한 액션보다 계산이 사용하기 쉽고, 계산보다 데이터를 사용하는 것이 쉽다고 한다.
예시로 데이터를 저장하고 조회해온다고 하면,<br/>
호출 받아 동작하는 서비스 로직의 한 트랜잭션(특정 리턴을 위해 동작하는 프로세스의 한 단위)을<span style="color: red;">액션</span>, <br/>
같은 값을 넣으면 같은 데이터를 저장, 조회하는 로직을 <span style="color: red;">계산</span> <br/>
그 인자와 리턴값, 필요에 의하면 DTO를<span style="color: red;">데이터</span><br/>
로 구분 하는 것 같다.<br/>
<br/>
이 예시에 대해서 처음에는 만족했지만 나중에 새로운 고민이 생겼다.<br/>
<b>만약 인자 데이터에 데이터의 기본 키가 포함되어 있고</b> 똑같이 <b>INSERT, CREATE</b> 를 해주는 로직을 탄다면 기본키 중복 예외를 뱉어낼텐데, 이는 계산이라고 할수 있는가?<br/>
같은 키의 데이터가 있다는 기준하에 그 이후에 실행되는 하나의 액션이 아닌가?<br/>
<br/>
이는 위의 구분에 대한 이해와 DB에 대한 공부가 부족해서 발생한 고민이었다.<br/>
<b>우선, 같은 값을 넣더라도 DB를 관리하는 로직이 들어간 이상, 위의 상황은 단순 계산이 아닌, 액션이다.</b><br/>
그리고 클라이언트는 기본키에 대하여 건드릴 수 있는 권한이 없다, 기본키는 데이터를 잘 관리하기 위한 필드이다.<br/>

<br/>

---
<br/>

### ● 액션, 계산, 데이터를 구분하면 어떤 장점이 있나요?

이렇게 액션, 계산, 데이터로 구분하는 함수형 프로그래밍은 요즘 유행하는 분산 시스템에 잘 어울리는 장점이 있다고 한다.<br/>

#### 분산 시스템 규칙 3가지
1. 메세지 순서가 바뀔 수 있다.
2. 메세지는 한 번 이상 도착 할 수도 있고 도착하지 않을 수도 있다.
3. 응답을 받지 못하면 무슨 일이 생겼는지 알 수 없다.

이는 함수형 프로그래밍이 단순한 트렌드가 아니라 <b>오랫동안 쌓아온 수학 지식을 기반으로 하는 프로그래밍 패러다임</b> 임을 의미하고, 
최근 늘어난 여러 기기 간의 통신을 담당하는 복잡한 소프트웨어에서 더욱 각광받게 되었다고 한다.<br/>

특히 시간에 따라 바뀌는 값을 리모델링 할 때 동작 방법을 이해하고, <b>실행 시점이나 횟수에 의존하는 코드를 없앤다면, 코드를 이해하기 더 쉬울 것</b>이다.<br/>

### ● 함수형 사고가 무엇인가요?

함수형 사고는 함수형 프로그래머가 소프트웨어 문제를 해결하기 위해 사용하는 기술과 생각이라고 한다.<br/>
함수형 사고에서 중요한 개념이 두 가지 있다.<br/>
<br/>
<b>액션, 계산, 데이터로 잘 분리하여 파악하는 것</b><br/>
<b>일급 추상(first-class abstraction)</b><br/>
<br/>
특히 액션, 계산, 데이터로 <b>구분하여 리팩터링(Refactoring)</b> 하는 방법 등을 다룰 것이라고 책이 말했다.<br/>
그리고 일급 추상은 재사용 되는 함수의 명을 어떻게 짓고 어떻게 쓰며 남용하지 않게 사용하는 방법을 설명할 것이라고 한다.<br/>

또 마지막에는 설계 관점에서 반응형 아키텍처(Reactive architecture)와 어니언 아키텍처(Onion architecture) 를 일급 추상과 연결해서 설명할 것이라고 한다.<br/>