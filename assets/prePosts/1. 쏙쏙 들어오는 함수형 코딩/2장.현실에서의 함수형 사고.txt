2장. 현실에서의 함수형 사고.

2023-05-15

책에서 함수형 프로그래밍의 기초가 되는 함수형 사고를 위해 예시를 들었다.
예시에 제목을 든다면 "어서오세요, 토니의 피자 샵" 정도가 되겠다.
주방과 재고 창고가 어떻게 관리되는지 확인하면서 함수형 사고를 접목 시켜보자고 한다.


※ 파트 1, 액션과 계산
요리 재료 등 자원(리소스, Resource)를 사용하는 코드를 액션으로 구분하고 나머지 코드는 계산으로 구분했다.
이에따라 발생할 액션, 계산, 데이터를 구분하고 계층형 설계(Stratified design)의 원칙을 접목시켜 알아보자.

※ 파트 2, 일급 추상
토니는 가게에서 로봇들과 같이 업무를 진행한다고 한다.
분명한 의미의 분산 시스템이고 가끔 실패하는 분산 시스템을 이해하려고 타임라인 다이어그램(Timeline diagram) 을 사용했다.
또 여러 로봇이 협력할 수 있도록 함수를 인자로 받는 일급 함수(First-class function) 을 사용했다.

이제 얼마나 더 빨리 많이 피자를 만들 수 있었는지 확인해보자.


※※ 파트 1: 액션과 계산, 데이터
매장이 빠르게 성장해 감에 따라 확장성 문제를 해결하기 위해 함수형 사고를 적용해서 어려움을 이겨내려 한다.
이를 위해 가장 먼저 설명했던 개념임 액션, 계산, 데이터로 구분하는 함수형 사고를 이용하려 한다.

※ 1. 액션
호출 횟수와 시점에 의존하는 것으로, 오븐이나 배달차량 같은 자원과 요리 재료를 사용하는 것은 액션이다.

예시:
1. 판죽 펴기
2. 피자 배달
3. 재료 주문


※ 2. 계산
어떤 것을 경정하거나 계획하는 것을 의미하고, 실행해도 다른 곳에 부수 효과가 발생하지 않는다.

예시:
1. 조리법에 나온 것을 두 배로 만들기
2. 쇼핑 목록 결정


※ 3. 데이터
변경 불가능한 데이터를 최대한 이용하려 한다.
결제, 재고, 피자 조리법 같은 것이 데이터로 유연하기 때문에 여러 방법으로 저장 가능하고 전송 가능하다.

예시:
1. 고객 주문
2. 영수증
3. 조리법


※※ 계층화 설계 맛보기
![image](https://github.com/4862abd/4862abd.github.io/assets/77370682/9eb488dd-b612-42d4-93f9-9e0b8a4f4f0e)

위 사진의 각 계층은 그 아래의 계층을 기반으로 만들어 진다.
그래서 더욱 안정적인 기반 위에 작성할 수 있으며, 이런 구조로 소프트웨어를 만들면 코드를 쉽게 변경할 수 있다.
또한, 가장 위에 있는 코드는 의존성이 거의 없기 때문에 쉽게 바꿀 수 있다는 장점이 생긴다.

이러한 패턴을 계층형 설계(Stratified design) 이라고 한다.
일반적으로 비즈니스 규칙, 도메인 규칙, 기술 스택 계층으로 나눠진다.


※※ 파트 2: 일급 추상
![image](https://github.com/4862abd/4862abd.github.io/assets/77370682/edbb0f90-2c31-45ca-b74d-dbd09ef7bd51)

위의 이미지는 한 대의 로봇이 주문을 받아 피자를 만들고 서빙하는 타임라인 다이어그램이다.
타임라인 다이어그램을 이용해서 실행 지점에 의존하는 개념의 액션이 시간 순서에 따라 어떻게 진행되는지 확인할 수 있다.


※※ 분산 시스템을 타임라인으로 시각화하기
한 대의 로봇이 처리할 일을 세 대로 확장시켜 업무의 효율성을 높이려 한다.
배정받을 업무는 이렇게 된다.
![image](https://github.com/4862abd/4862abd.github.io/assets/77370682/df723d65-8691-4461-96f4-be01743de0e2)

각 세대의 타임라인이 섞여 있어서 누가 먼저 시작하고 끝나는지 확인할 수 없다.
이러한 타임라인대로 흘러간다면 피자가 만들어 질지, 어떤 피자가 만들어질지 확인할 수 없다.

우선 업무를 분담한 대로
1. 반죽 만들기
2. 치즈 갈기
3. 소스 만들기 등 잡다
로 나눠보자.

반죽을 만들거나 치즈를 가는 것은 업무의 순서에서 중요한 포인트이다.
반죽을 펴고 소스를 뿌려야하는데 반죽은 아직 만들어 지지 않았을 수 있다.
또, 소스를 뿌렸다면 치즈를 뿌려야 하는데 치즈 갈기가 미리 되지 않으면 뿌릴 치즈가 없다.
즉, 반죽을 만들고 펴고, 치즈를 갈고 뿌리고, 소스를 만들어 뿌리는 작업 중, 소스를 만들어 뿌리는 작업이 가장 마지막으로 와야한다.
위의 세가지 업무에서 카테시안 곱(Cartesian product)을 이용해 만들어진 조합 중, 이상적인 조합은 두 가지가 나온다.

1. 반죽 만들기
2. 치즈 갈기
3. 소스 만들고 뿌리기

혹은

1. 치즈 갈기
2. 반죽 만들기
3. 소스 만들고 뿌리기

가 가능한 순서일 것이다.
이렇게 타임라인을 서로 맞추지 않는 분산 시스템은 예측 불가능한 순서로 실행된다.

이러한 과정을 통해 피자가게 사장인 토니는 몇가지 포인트를 얻었다고 한다.
1. 기본적으로 타임라인은 서로 순서를 맞추지 않습니다.
ㄴ 반죽을 만들지 않아도 소스를 바르려고 하는 등, 타임라인이 제대로 흐르지 않았습니다.

2. 액션이 실행되는 시간은 중요하지 않습니다.
ㄴ 소스를 만드는 것이 가장 오래 걸리는 작업이라고 해도 순서에 관계없이 만들어야 한다.

3. 드물지만 타이밍이 어긋나는 경우는 실제로 일어납니다.
ㄴ 테스트 시에는 문제 없던 로직이 실제로 동작하거나 너무 많은 요청이 일어나면 오류가 발생했다.

4. 타임라인 다이어그램으로 시스템의 문제를 알 수 있습니다.
ㄴ 타임라인 다이어그램을 보고 치즈가 제 시간에 준비되지 않은 문제를 파악했다.

이제 해결법을 찾으려 한다.


※※ 타임라인 커팅: 로봇이 서로를 기다릴 수 있게 하기
타임라인 커팅(Cutting) 이라고 부르는 기술을 접목시키려 한다.
이는 여러 타임라인이 동시에 진행될 때 서로 순서를 맞추는 방법이라고 하며, 고차 동작(High-order operation)으로 구현한다.
각 타임라인은 독립적으로 동작하고 작업이 완료되는 다른 타임라인이 끝나기를 기다리기 때문에 어떤 타임라인이 먼저 종료되어도 문제는 없다.

![image](https://github.com/4862abd/4862abd.github.io/assets/77370682/1e5aeae7-ccdf-4f25-9fb6-a3943c92d933)
이미지의 중간에 점선을 컷(Cut) 이라고 한다.
마치 종이접기 책에서 접거나 가위로 자르는 부분을 설명할 때 그것과 비슷해 보인다.

이제 순서에 상관없이 특정 작업이 마치면 다음 로직이 진행되기 전까지 대기하는 타임라인 다이어그램을 완성했다.


※※ 좋은 경험을 통해 타임라인에 대해 배운 것

1. 타임라인 커팅으로 서로 다른 작업들을 쉽게 이해할 수 있습니다.
ㄴ 타임라인에 컷을 이용함으로 인해 동시에 준비할 수 있는 재료의 준비에 유연성을 확보 했다.
ㄴ 또한 피자를 만드는 작업과 재료를 준비하는 작업을 분리함으로 순서대로만 연결되던 타임라인보다 더 빠르게 생산할 수 있게 되었다.

2. 타임라인 다이어그램을 사용하면 시간에 따라 진행하는 작업을 쉽게 이해할 수 있습니다.
ㄴ 토니와 나는 이제 타임라인 다이어그램을 이해할 수 있었지에 동작에 확신이 생겼고, 또한 분산 시스템을 시각화할 수 있는 좋은 방법이 생겼다.

3. 타임라인 다이어그램은 유연합니다.
ㄴ 이제 이 타임라인 다이어그램을 통해 쉽게 코딩을 할 수 있고, 동시에 진행되는 작업을 쉽게 모델링 할 수 있다.
